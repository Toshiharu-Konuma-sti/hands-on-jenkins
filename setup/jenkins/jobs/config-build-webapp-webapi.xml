<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition"/>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition">
      <jobProperties/>
      <triggers/>
      <parameters/>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <com.dabsquared.gitlabjenkins.connection.GitLabConnectionProperty plugin="gitlab-plugin">
      <gitLabConnection></gitLabConnection>
      <jobCredentialId></jobCredentialId>
      <useAlternativeCredential>false</useAlternativeCredential>
    </com.dabsquared.gitlabjenkins.connection.GitLabConnectionProperty>
    <org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
      <triggers>
        <com.dabsquared.gitlabjenkins.GitLabPushTrigger plugin="gitlab-plugin">
          <spec></spec>
          <triggerOnPush>false</triggerOnPush>
          <triggerToBranchDeleteRequest>false</triggerToBranchDeleteRequest>
          <triggerOnMergeRequest>false</triggerOnMergeRequest>
          <triggerOnlyIfNewCommitsPushed>false</triggerOnlyIfNewCommitsPushed>
          <triggerOnPipelineEvent>false</triggerOnPipelineEvent>
          <triggerOnAcceptedMergeRequest>true</triggerOnAcceptedMergeRequest>
          <triggerOnClosedMergeRequest>false</triggerOnClosedMergeRequest>
          <triggerOnApprovedMergeRequest>false</triggerOnApprovedMergeRequest>
          <triggerOpenMergeRequestOnPush>never</triggerOpenMergeRequestOnPush>
          <triggerOnNoteRequest>false</triggerOnNoteRequest>
          <noteRegex>Jenkins please retry a build</noteRegex>
          <ciSkip>true</ciSkip>
          <skipWorkInProgressMergeRequest>true</skipWorkInProgressMergeRequest>
          <labelsThatForcesBuildIfAdded></labelsThatForcesBuildIfAdded>
          <setBuildDescription>true</setBuildDescription>
          <branchFilterType>All</branchFilterType>
          <includeBranchesSpec></includeBranchesSpec>
          <excludeBranchesSpec></excludeBranchesSpec>
          <sourceBranchRegex></sourceBranchRegex>
          <targetBranchRegex></targetBranchRegex>
          <secretToken>1234567890abcdefghijklmnopqrstuvwxyz</secretToken>
          <pendingBuildName></pendingBuildName>
          <cancelPendingBuildsOnUpdate>false</cancelPendingBuildsOnUpdate>
        </com.dabsquared.gitlabjenkins.GitLabPushTrigger>
      </triggers>
    </org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps">
    <script>@NonCPS
def parseJarName(String jarFileName) {
    def matcher = jarFileName =~ /^(.*)-(\d+\.\d+\.\d+)-SNAPSHOT\.jar$/
    if (matcher.matches()) {
        return [matcher[0][1], matcher[0][2]]
    }
    return null
}

pipeline{
    agent{
        label &apos;master&apos;
    }
    tools {
        jfrog &apos;my-jfrog-cli&apos;
        gradle &apos;my-gradle&apos;
    }
    environment {
        GIT_REPO_URL = &apos;http://gitlab:13000/root/webapp-webapi.git&apos;
        JAR_FILE_PATTERN = &apos;build/libs/apisl.handson.rollingdice.webapp.webapi-*-SNAPSHOT.jar&apos;
        ARTIFACTORY_URL = &apos;http://artifactory:8081/artifactory&apos;
        ARTIFACTORY_REPO = &apos;hands-on-rollingdice-webapp-webapi&apos;
        SBOM_FILE_PATH = &apos;build/reports/application.cdx.json&apos;
        DEPENDENCY_TRACK_API_KEY_ID = &apos;dependency-track-api-key&apos;
    }
    stages{
//        stage(&quot;Clean up a local environment&quot;){
//            steps{
//                echo &quot;### START: clean up the cloned directoy&quot;
//                deleteDir()
//            }
//        }
        stage(&quot;Checkout a repository from GitLab&quot;){
            steps{
               echo &quot;### START: clone a repository from GitLab&quot;
               git branch: &apos;main&apos;, url: &quot;${env.GIT_REPO_URL}&quot;
            }
        }
        stage(&apos;Build with JFrog CLI&apos;) {
            steps {
                echo &quot;### START: build with jfrog cli&quot;
                jf &apos;gradle-config --repo-deploy ${ARTIFACTORY_REPO}&apos;
                jf &quot;rt gradle assemble -x cyclonedxBom --info --build-name=${ARTIFACTORY_REPO} --build-number=${BUILD_NUMBER}&quot;
            }
        }
        stage(&apos;Generate SBOM&apos;) {
            steps {
                echo &quot;### START: generate SBOM using CycloneDX plugin&quot;
                sh &apos;./gradlew cyclonedxBom --info&apos;
            }
        }
        stage(&apos;Publish SBOM to Dependency-Track&apos;) {
            steps {
                echo &quot;### START: publich SBOM to Dependency-Track&quot;
                script {
                    // 1. Get the full path of the JAR files that match a pattern.
                    def jarFilePath = sh(script: &quot;find . -path &apos;./${env.JAR_FILE_PATTERN}&apos;&quot;, returnStdout: true).trim()
                    if (jarFilePath.isEmpty()) {
                        error &quot;JAR file not found with pattern: ${env.JAR_FILE_PATTERN}&quot;
                    }
                  
                    // 2. Extract only the file name from the full path.
                    def jarFileName = sh(script: &quot;basename &apos;${jarFilePath}&apos;&quot;, returnStdout: true).trim()
                    echo &quot;Found JAR file: ${jarFileName}&quot;
                    
                    // 3. Extract project name and version using regular expressions.
                    def projectInfo = parseJarName(jarFileName)
                    if (projectInfo == null) {
                        error &quot;Could not parse project name and version from JAR file: ${jarFileName}&quot;
                    }

                    def parsedProjectName = projectInfo[0]
                    def parsedProjectVersion = projectInfo[1]
                    echo &quot;Parsed Project Name: ${parsedProjectName}&quot;
                    echo &quot;Parsed Project Version: ${parsedProjectVersion}&quot;
                  
                    withCredentials([string(credentialsId: &quot;${env.DEPENDENCY_TRACK_API_KEY_ID}&quot;, variable: &apos;API_KEY&apos;)]) {
                        dependencyTrackPublisher artifact: &quot;${env.SBOM_FILE_PATH}&quot;,
                        projectName: parsedProjectName,
                        projectVersion: parsedProjectVersion,
                        synchronous: true,
                        dependencyTrackApiKey: API_KEY
                    }
                }
            }
        }
        stage(&quot;Run Unit Tests&quot;){
            steps{
                echo &quot;### START: run unit tests&quot;
                sh &quot;./gradlew test -x check --info&quot;
            }
            post {
                always {
                    junit &apos;build/test-results/test/*.xml&apos;
                }
            }
        }
        stage(&quot;Analyze test codes coverage&quot;){
            steps{
                echo &quot;### START: analyze a test code coverage&quot;
                sh &quot;./gradlew jacocoTestReport --info&quot;
            }
            post {
                always {
                    recordCoverage(
                        tools: [[parser: &apos;JACOCO&apos;, pattern: &apos;build/reports/jacoco/test/jacocoTestReport.xml&apos;]],
                        id: &apos;jacoco&apos;, name: &apos;JaCoCo Coverage&apos;,
                        sourceCodeRetention: &apos;EVERY_BUILD&apos;,
                        qualityGates: [
                            [threshold: 60.0, metric: &apos;LINE&apos;, baseline: &apos;PROJECT&apos;, unstable: true],
                            [threshold: 60.0, metric: &apos;BRANCH&apos;, baseline: &apos;PROJECT&apos;, unstable: true]]
                    )
                }
            }
        }
        stage(&quot;Analyze codes with Checkstyle&quot;){
            steps{
                echo &quot;### START: analyze codes with checkstyle&quot;
                sh &quot;./gradlew checkstyleMain checkstyleTest --info&quot;
            }
            post {
                always {
                    recordIssues tools: [
                        checkStyle(pattern: &apos;build/reports/checkstyle/&apos;)
                    ]
                }
            }
        }
        stage(&quot;Analyze codes with PMD&quot;){
            steps{
                echo &quot;### START: analyze codes with pmd&quot;
                sh &quot;./gradlew pmdMain pmdTest --info&quot;
            }
            post {
                always {
                    recordIssues tools: [
                        pmdParser(pattern: &apos;build/reports/pmd/*.xml&apos;)
                    ]
                }
            }
        }
        stage(&apos;Generate a Javadoc&apos;) {
            steps {
                echo &quot;### START: generate a javadoc&quot;
                sh &apos;./gradlew javadoc&apos;
            }
        }
        stage(&apos;Publish a Javadoc&apos;) {
            steps {
                echo &quot;### START: publish a javadoc using javadoc plugin&quot;
                javadoc javadocDir: &apos;build/docs/javadoc&apos;, keepAll: true
            }
        }
        stage(&apos;Release an artifact to Artifactory&apos;) {
            steps {
                echo &quot;### START: release an artifact to artifactory&quot;
                jf &apos;rt u ${JAR_FILE_PATTERN} ${ARTIFACTORY_REPO}&apos;
            }
        }
        stage(&apos;Publish a build info to Artifactory&apos;) {
            steps {
                echo &quot;### START: publish a build info to Artifactory&quot;
                jf &quot;rt build-publish ${ARTIFACTORY_REPO} ${BUILD_NUMBER}&quot;
            }
        }
    }
    post{
        always{
            echo &quot;========always========&quot;
        }
        success{
            echo &quot;========pipeline executed successfully ========&quot;
        }
        failure{
            echo &quot;========pipeline execution failed========&quot;
        }
    }
}</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>
