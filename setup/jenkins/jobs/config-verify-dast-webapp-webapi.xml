<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition"/>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition">
      <jobProperties/>
      <triggers/>
      <parameters/>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <com.dabsquared.gitlabjenkins.connection.GitLabConnectionProperty plugin="gitlab-plugin">
      <gitLabConnection></gitLabConnection>
      <jobCredentialId></jobCredentialId>
      <useAlternativeCredential>false</useAlternativeCredential>
    </com.dabsquared.gitlabjenkins.connection.GitLabConnectionProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps">
    <script>pipeline{
    agent{
        label &apos;master&apos;
    }
    tools {
        jfrog &apos;my-jfrog-cli&apos;
        gradle &apos;my-gradle&apos;
    }
    environment {
        GIT_REPO_URL = &apos;http://gitlab:13000/root/webapp-webapi.git&apos;
        JAR_FILE_PATTERN = &apos;webapi/build/libs/apisl.handson.rollingdice.webapp.webapi-*-SNAPSHOT.jar&apos;
        ARTIFACTORY_REPO = &apos;hands-on-rollingdice-webapp-webapi&apos;
        ARTIFACTORY_VIRTUAL_REPO = &apos;gradle-virtual&apos;
        
        TARGET_URL = &quot;http://localhost:8182&quot;
        HEALTH_CHECK_URL = &quot;${TARGET_URL}/actuator/health&quot;
        ZAP_REPORT_NAME = &quot;zap-baseline-report.html&quot;
    }
    stages{
        stage(&quot;Clean up a local environment&quot;){
            steps{
                echo &quot;### START: clean up the cloned directoy&quot;
                deleteDir()
            }
        }
        stage(&quot;Checkout a repository from GitLab&quot;){
            steps{
               echo &quot;### START: clone a repository from GitLab&quot;
               dir(&apos;webapi&apos;) {
                   git url: &quot;${env.GIT_REPO_URL}&quot;, branch: &apos;main&apos;
               }
               sh &apos;ls -la&apos;
               sh &apos;ls -la webapi&apos;
            }
        }
        stage(&apos;Build with JFrog CLI&apos;) {
            steps {
                echo &quot;### START: build with jfrog cli&quot;
                dir(&apos;webapi&apos;) {
                    jf &quot;gradle-config --repo-deploy ${ARTIFACTORY_REPO} --repo-resolve ${ARTIFACTORY_VIRTUAL_REPO}&quot;
                    jf &quot;gradle assemble -x cyclonedxBom --info --build-name=${ARTIFACTORY_REPO} --build-number=${BUILD_NUMBER}&quot;
                }
                sh &apos;ls -la&apos;
                sh &apos;ls -la webapi&apos;
            }
        }

        stage(&apos;Run DAST with OWASP ZAP (Docker)&apos;) {
            steps {
                script {
                    echo &quot;### START: run dast with owasp zap (docker)&quot;
                    
                    def jarFile = sh(script: &quot;ls ${env.JAR_FILE_PATTERN}&quot;, returnStdout: true).trim()

                    if (jarFile.isEmpty()) {
                        error &quot;JAR file not found with pattern: ${env.JAR_FILE_PATTERN}&quot;
                    }
                    echo &quot;Found JAR file: ${jarFile}&quot;

                    def containerName = &quot;zap-scan-${BUILD_NUMBER}&quot;
                    def mysqlContainerName = &quot;mysql-${BUILD_NUMBER}&quot;

                    try {

                        echo &quot;### START: Checkout MySQL configuration&quot;
                        dir(&apos;webapp-repo&apos;) {
                            git url: &apos;https://github.com/Toshiharu-Konuma-sti/hands-on-rollingdice-webapp.git&apos;, branch: &apos;main&apos;
                        }
                        sh &apos;ls -la&apos;
                        sh &apos;ls -la webapp-repo&apos;

                        echo &quot;### START: Launching MySQL container&quot;
                        echo &quot;${WORKSPACE}&quot;
                        sh &quot;ls -lF ${WORKSPACE}/webapp-repo/&quot;
                        sh &quot;ls -lF ${WORKSPACE}/webapp-repo/mysql/&quot;
                        sh &quot;ls -lF ${WORKSPACE}/webapp-repo/mysql/init/&quot;
                        sh &quot;&quot;&quot;
                            docker create --name ${mysqlContainerName} \\
                                -h zap-mysql \\
                                --network intra-net \\
                                -e MYSQL_ROOT_PASSWORD=password \\
                                -e MYSQL_DATABASE=hands_on_db \\
                                -e MYSQL_USER=myuser \\
                                -e MYSQL_PASSWORD=mypass \\
                                -e TZ=&quot;Asia/Tokyo&quot; \\
                                mysql:8.0
                        &quot;&quot;&quot;

                        echo &quot;### 2. Copying configuration files to MySQL container&quot;
                        sh &quot;docker cp ${WORKSPACE}/webapp-repo/mysql/config/my.cnf ${mysqlContainerName}:/etc/mysql/conf.d/my.cnf&quot;
                        sh &quot;docker cp ${WORKSPACE}/webapp-repo/mysql/init/init.sql ${mysqlContainerName}:/docker-entrypoint-initdb.d/init.sql&quot;
                        
                        echo &quot;### 3. Starting MySQL container&quot;
                        sh &quot;docker start ${mysqlContainerName}&quot;

                        echo &quot;Waiting for MySQL server to start...&quot;
                        timeout(time: 2, unit: &apos;MINUTES&apos;) {
                            sh &quot;until docker exec ${mysqlContainerName} mysqladmin ping -h 127.0.0.1 --silent; do echo &apos;Waiting for mysql...&apos;; sleep 5; done&quot;
                        }
                        echo &quot;MySQL is up and running.&quot;


                        sh &quot;docker logs ${mysqlContainerName}&quot;
                        sh &quot;docker exec ${mysqlContainerName} ls -lF /docker-entrypoint-initdb.d/&quot;
                        sh &quot;docker exec ${mysqlContainerName} mysql -u myuser -pmypass -e &apos;SHOW DATABASES; USE hands_on_db; SHOW TABLES;&apos;&quot;


                        sh &quot;&quot;&quot;
                            export SPRING_PROFILES_ACTIVE=zap
                            nohup java -jar ${jarFile} \
                                --management.otlp.metrics.export.enabled=false \
                                --otel.sdk.disabled=true \
                                &gt; app.log 2&gt;&amp;1 &amp; echo \$! &gt; app.pid
                        &quot;&quot;&quot;
                        echo &quot;Waiting for application to start...&quot;

                        timeout(time: 1, unit: &apos;MINUTES&apos;) {
                            sh &quot;until curl -s -o /dev/null -w &apos;%{http_code}&apos; ${env.HEALTH_CHECK_URL} | grep -q &apos;^[245]&apos;; do echo &apos;Waiting for app...&apos;; sleep 5; done&quot;
                        }

                        echo &quot;Application is up and running.&quot;

                        echo &quot;### START: DAST scan with OWASP ZAP Docker container&quot;

                        writeFile(file: &apos;zap_warn_rules.xml&apos;, text: &apos;&lt;rules&gt;&lt;/rules&gt;&apos;)

                        sh &apos;id&apos;
                        def jenkinsUser = sh(script: &apos;id -u&apos;, returnStdout: true).trim()
                        def jenkinsGroup = sh(script: &apos;id -g&apos;, returnStdout: true).trim()

                        sh &apos;export SPRING_PROFILES_ACTIVE=zap&apos;
                        sh &quot;&quot;&quot;
                            docker run --name ${containerName} --network host \\
                                -w /zap/wrk \\
                                -u ${jenkinsUser}:${jenkinsGroup} \\
                                -v ${WORKSPACE}:/zap/wrk/:rw \\
                                ghcr.io/zaproxy/zaproxy:stable \\
                                /bin/bash -c &quot;zap-baseline.py -t ${env.TARGET_URL} -r ${env.ZAP_REPORT_NAME} -w zap_warn_rules.xml -l WARN -d &amp;&amp; echo &apos;--- ZAP Container ls -la /zap/wrk ---&apos; &amp;&amp; ls -la /zap/wrk&quot;
                        &quot;&quot;&quot;

                        echo &quot;Copying &apos;${env.ZAP_REPORT_NAME}&apos; from container &apos;${containerName}&apos; to workspace...&quot;
                        sh &quot;docker cp ${containerName}:/zap/wrk/${env.ZAP_REPORT_NAME} .&quot;
                        
                        echo &quot;Copying &apos;zap_warn_rules.xml&apos; from container &apos;${containerName}&apos; to workspace...&quot;
                        sh &quot;docker cp ${containerName}:/zap/wrk/zap_warn_rules.xml .&quot;

                    } finally {

                        if (mysqlContainerName) {
                            echo &quot;Cleaning up MySQL container: ${mysqlContainerName}&quot;
                            sh &quot;docker rm -f ${mysqlContainerName} || true&quot;
                        }

                        if (containerName) {
                            echo &quot;Cleaning up ZAP container: ${containerName}&quot;
                            sh &quot;docker rm -f ${containerName} || true&quot;
                        }

                        if (fileExists(&apos;webapi/app.log&apos;)) {
                            echo &quot;--- Displaying application log (app.log) ---&quot;
                            sh &apos;cat webapi/app.log&apos;
                            echo &quot;--------------------------------------------&quot;
                        }
                        echo &quot;Stopping application...&quot;
                        if (fileExists(&apos;webapi/app.pid&apos;)) {
                            sh &apos;kill `cat webapi/app.pid` || true&apos;
                        }

                        echo &quot;Listing workspace files before archiving...&quot;
                        sh &apos;ls -la&apos;
                    }
                }
            }
            post {
                always {
                    echo &quot;Archiving artifacts...&quot;
                    archiveArtifacts artifacts: &quot;${env.ZAP_REPORT_NAME}, app.log&quot;, allowEmptyArchive: false
                    
                    echo &quot;Publishing DAST report...&quot;
                    publishHTML(target: [
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: &apos;.&apos;,
                        reportFiles: &quot;${env.ZAP_REPORT_NAME}&quot;,
                        reportName: &apos;DAST Scan Report(webapi)&apos;
                    ])
                }
            }
        }

    }
    post{
        always{
            echo &quot;========always========&quot;
        }
        success{
            echo &quot;========pipeline executed successfully ========&quot;
        }
        failure{
            echo &quot;========pipeline execution failed========&quot;
        }
    }
}</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>
