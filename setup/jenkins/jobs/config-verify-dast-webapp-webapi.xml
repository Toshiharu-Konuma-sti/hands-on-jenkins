<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition"/>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition">
      <jobProperties/>
      <triggers/>
      <parameters/>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <com.dabsquared.gitlabjenkins.connection.GitLabConnectionProperty plugin="gitlab-plugin">
      <gitLabConnection></gitLabConnection>
      <jobCredentialId></jobCredentialId>
      <useAlternativeCredential>false</useAlternativeCredential>
    </com.dabsquared.gitlabjenkins.connection.GitLabConnectionProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps">
    <script>pipeline{
    agent{
        label &apos;master&apos;
    }
    tools {
        jfrog &apos;my-jfrog-cli&apos;
        gradle &apos;my-gradle&apos;
    }
    environment {
        SERVICES_LIST = &apos;webapi,webui&apos;
        
//        GIT_REPO_URL = &apos;http://gitlab:13000/root/webapp-webapi.git&apos;
        JAR_FILE_PATTERN_API = &apos;webapi/build/libs/apisl.handson.rollingdice.webapp.webapi-*-SNAPSHOT.jar&apos;

        TARGET_URL_API = &quot;http://localhost:8182&quot;
        HEALTH_CHECK_URL_API = &quot;${TARGET_URL_API}/actuator/health&quot;
        ZAP_REPORT_NAME_API = &quot;zap-baseline-report.html&quot;
    }
    stages{
        stage(&quot;Clean up a local environment&quot;){
            steps{
                echo &quot;### START: clean up the cloned directoy&quot;
                deleteDir()
            }
        }
        stage(&quot;Checkout a repository from GitLab and Build&quot;){
            steps{
                script {
                    def services = env.SERVICES_LIST.split(&apos;,&apos;)
                    services.each { serviceName -&gt;
                        echo &quot;--- Processing service: ${serviceName} ---&quot;
                        def serviceGitUrl = &quot;http://gitlab:13000/root/webapp-${serviceName}.git&quot;
                        dir(serviceName) {
                            echo &quot;### [${serviceName}] START: Cloning repository from ${serviceGitUrl}&quot;
                            git url: serviceGitUrl, branch: &apos;main&apos;
                            echo &quot;### [${serviceName}] START: Building with Gradle&quot;
                            sh &quot;./gradlew assemble -x cyclonedxBom --info&quot;
                        }
                    }
                }
            }
        }

        stage(&apos;Run DAST with OWASP ZAP (Docker)&apos;) {
            steps {
                script {
                    echo &quot;### START: run dast with owasp zap (docker)&quot;
                    
                    def jarFile_api = sh(script: &quot;ls ${env.JAR_FILE_PATTERN_API}&quot;, returnStdout: true).trim()

                    if (jarFile_api.isEmpty()) {
                        error &quot;JAR file not found with pattern: ${env.JAR_FILE_PATTERN_API}&quot;
                    }
                    echo &quot;Found JAR file: ${jarFile_api}&quot;

                    def containerName = &quot;zap-scan-${BUILD_NUMBER}&quot;
                    def mysqlContainerName = &quot;mysql-${BUILD_NUMBER}&quot;

                    try {

                        echo &quot;### START: Checkout MySQL configuration&quot;
                        dir(&apos;webapp-repo&apos;) {
                            git url: &apos;https://github.com/Toshiharu-Konuma-sti/hands-on-rollingdice-webapp.git&apos;, branch: &apos;main&apos;
                        }

                        echo &quot;### START: Creating MySQL container&quot;
                        sh &quot;&quot;&quot;
                            docker create --name ${mysqlContainerName} \\
                                -h zap-mysql \\
                                --network intra-net \\
                                -e MYSQL_ROOT_PASSWORD=password \\
                                -e MYSQL_DATABASE=hands_on_db \\
                                -e MYSQL_USER=myuser \\
                                -e MYSQL_PASSWORD=mypass \\
                                -e TZ=&quot;Asia/Tokyo&quot; \\
                                mysql:8.0
                        &quot;&quot;&quot;

                        echo &quot;### START: Copying configuration files to MySQL container&quot;
                        sh &quot;docker cp ${WORKSPACE}/webapp-repo/mysql/config/my.cnf ${mysqlContainerName}:/etc/mysql/conf.d/my.cnf&quot;
                        sh &quot;docker cp ${WORKSPACE}/webapp-repo/mysql/init/init.sql ${mysqlContainerName}:/docker-entrypoint-initdb.d/init.sql&quot;
                        
                        echo &quot;### START: Starting MySQL container&quot;
                        sh &quot;docker start ${mysqlContainerName}&quot;

                        echo &quot;Waiting for MySQL server to start...&quot;
                        timeout(time: 2, unit: &apos;MINUTES&apos;) {
                            sh &quot;until docker exec ${mysqlContainerName} mysqladmin ping -h 127.0.0.1 --silent; do echo &apos;Waiting for mysql...&apos;; sleep 5; done&quot;
                        }
                        echo &quot;MySQL is up and running.&quot;

                        echo &quot;### START: Starting WebApp container&quot;
                        sh &quot;&quot;&quot;
                            export SPRING_PROFILES_ACTIVE=zap
                            nohup java -jar ${jarFile_api} \
                                --management.otlp.metrics.export.enabled=false \
                                --otel.sdk.disabled=true \
                                &gt; webapp-webapi.log 2&gt;&amp;1 &amp; echo \$! &gt; webapp-webapi.pid
                        &quot;&quot;&quot;
                        echo &quot;Waiting for application to start...&quot;
                        timeout(time: 1, unit: &apos;MINUTES&apos;) {
                            sh &quot;until curl -s -o /dev/null -w &apos;%{http_code}&apos; ${env.HEALTH_CHECK_URL_API} | grep -q &apos;^[245]&apos;; do echo &apos;Waiting for app...&apos;; sleep 5; done&quot;
                        }
                        echo &quot;Application is up and running.&quot;



                        echo &quot;### START: DAST scan with OWASP ZAP Docker container&quot;
                        writeFile(file: &apos;zap_warn_rules.xml&apos;, text: &apos;&lt;rules&gt;&lt;/rules&gt;&apos;)
                        sh &apos;id&apos;
                        def jenkinsUser = sh(script: &apos;id -u&apos;, returnStdout: true).trim()
                        def jenkinsGroup = sh(script: &apos;id -g&apos;, returnStdout: true).trim()

                        sh &quot;&quot;&quot;
                            docker run --name ${containerName} --network host \\
                                -w /zap/wrk \\
                                -u ${jenkinsUser}:${jenkinsGroup} \\
                                -v ${WORKSPACE}:/zap/wrk/:rw \\
                                ghcr.io/zaproxy/zaproxy:stable \\
                                /bin/bash -c &quot;zap-baseline.py -t ${env.TARGET_URL_API} -r ${env.ZAP_REPORT_NAME_API} -w zap_warn_rules.xml -l WARN -d &amp;&amp; echo &apos;--- ZAP Container ls -la /zap/wrk ---&apos; &amp;&amp; ls -la /zap/wrk&quot;
                        &quot;&quot;&quot;

                        echo &quot;Copying &apos;${env.ZAP_REPORT_NAME_API}&apos; from container &apos;${containerName}&apos; to workspace...&quot;
                        sh &quot;docker cp ${containerName}:/zap/wrk/${env.ZAP_REPORT_NAME_API} .&quot;
                        
                        echo &quot;Copying &apos;zap_warn_rules.xml&apos; from container &apos;${containerName}&apos; to workspace...&quot;
                        sh &quot;docker cp ${containerName}:/zap/wrk/zap_warn_rules.xml .&quot;

                    } finally {

                        if (mysqlContainerName) {
                            echo &quot;Cleaning up MySQL container: ${mysqlContainerName}&quot;
                            sh &quot;docker rm -f ${mysqlContainerName} || true&quot;
                        }

                        if (containerName) {
                            echo &quot;Cleaning up ZAP container: ${containerName}&quot;
                            sh &quot;docker rm -f ${containerName} || true&quot;
                        }

                        if (fileExists(&apos;webapp-webapi.log&apos;)) {
                            echo &quot;--- Displaying application log (app.log) ---&quot;
                            sh &apos;cat webapp-webapi.log&apos;
                            echo &quot;--------------------------------------------&quot;
                        }
                        echo &quot;Stopping application...&quot;
                        if (fileExists(&apos;webapp-webapi.pid&apos;)) {
                            sh &apos;kill `cat webapp-webapi.pid` || true&apos;
                        }

                        echo &quot;Listing workspace files before archiving...&quot;
                        sh &apos;ls -la&apos;
                    }
                }
            }
            post {
                always {
                    echo &quot;Archiving artifacts...&quot;
                    archiveArtifacts artifacts: &quot;${env.ZAP_REPORT_NAME_API}, app.log&quot;, allowEmptyArchive: false
                    
                    echo &quot;Publishing DAST report...&quot;
                    publishHTML(target: [
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: &apos;.&apos;,
                        reportFiles: &quot;${env.ZAP_REPORT_NAME_API}&quot;,
                        reportName: &apos;DAST Scan Report&apos;
                    ])
                }
            }
        }

    }
    post{
        always{
            echo &quot;========always========&quot;
        }
        success{
            echo &quot;========pipeline executed successfully ========&quot;
        }
        failure{
            echo &quot;========pipeline execution failed========&quot;
        }
    }
}</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>
