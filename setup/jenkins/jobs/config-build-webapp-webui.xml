<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition"/>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition">
      <jobProperties/>
      <triggers/>
      <parameters/>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <com.dabsquared.gitlabjenkins.connection.GitLabConnectionProperty plugin="gitlab-plugin">
      <gitLabConnection></gitLabConnection>
      <jobCredentialId></jobCredentialId>
      <useAlternativeCredential>false</useAlternativeCredential>
    </com.dabsquared.gitlabjenkins.connection.GitLabConnectionProperty>
    <org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
      <triggers>
        <com.dabsquared.gitlabjenkins.GitLabPushTrigger plugin="gitlab-plugin">
          <spec></spec>
          <triggerOnPush>false</triggerOnPush>
          <triggerToBranchDeleteRequest>false</triggerToBranchDeleteRequest>
          <triggerOnMergeRequest>false</triggerOnMergeRequest>
          <triggerOnlyIfNewCommitsPushed>false</triggerOnlyIfNewCommitsPushed>
          <triggerOnPipelineEvent>false</triggerOnPipelineEvent>
          <triggerOnAcceptedMergeRequest>true</triggerOnAcceptedMergeRequest>
          <triggerOnClosedMergeRequest>false</triggerOnClosedMergeRequest>
          <triggerOnApprovedMergeRequest>false</triggerOnApprovedMergeRequest>
          <triggerOpenMergeRequestOnPush>never</triggerOpenMergeRequestOnPush>
          <triggerOnNoteRequest>false</triggerOnNoteRequest>
          <noteRegex>Jenkins please retry a build</noteRegex>
          <ciSkip>true</ciSkip>
          <skipWorkInProgressMergeRequest>true</skipWorkInProgressMergeRequest>
          <labelsThatForcesBuildIfAdded></labelsThatForcesBuildIfAdded>
          <setBuildDescription>true</setBuildDescription>
          <branchFilterType>All</branchFilterType>
          <includeBranchesSpec></includeBranchesSpec>
          <excludeBranchesSpec></excludeBranchesSpec>
          <sourceBranchRegex></sourceBranchRegex>
          <targetBranchRegex></targetBranchRegex>
          <secretToken>1234567890abcdefghijklmnopqrstuvwxyz</secretToken>
          <pendingBuildName></pendingBuildName>
          <cancelPendingBuildsOnUpdate>false</cancelPendingBuildsOnUpdate>
        </com.dabsquared.gitlabjenkins.GitLabPushTrigger>
      </triggers>
    </org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps">
    <script>@NonCPS
def parseJarName(String jarFileName) {
    def matcher = jarFileName =~ /^(.*)-(\d+\.\d+\.\d+)-SNAPSHOT\.jar$/
    if (matcher.matches()) {
        return [matcher[0][1], matcher[0][2]]
    }
    return null
}

def testResultsProps = &quot;&quot;

pipeline{
    agent{
        label &apos;master&apos;
    }
    tools {
        jfrog &apos;my-jfrog-cli&apos;
        gradle &apos;my-gradle&apos;
    }
    environment {
        GIT_REPO_URL = &apos;http://gitlab:13000/root/webapp-webui.git&apos;
        JAR_FILE_PATTERN = &apos;build/libs/apisl.handson.rollingdice.webapp.webui-*-SNAPSHOT.jar&apos;
        ARTIFACTORY_REPO = &apos;hands-on-rollingdice-webapp-webui&apos;
        ARTIFACTORY_VIRTUAL_REPO = &apos;gradle-virtual&apos;
        SBOM_FILE_PATH = &apos;build/reports/application.cdx.json&apos;
        DEPENDENCY_TRACK_API_KEY_ID = &apos;dependency-track-api-key&apos;
    }
    stages{
//        stage(&quot;Clean up a local environment&quot;){
//            steps{
//                echo &quot;### START: clean up the cloned directoy&quot;
//                deleteDir()
//            }
//        }
        stage(&quot;Checkout a repository from GitLab&quot;){
            steps{
               echo &quot;### START: clone a repository from GitLab&quot;
               git branch: &apos;main&apos;, url: &quot;${env.GIT_REPO_URL}&quot;
            }
        }
        stage(&apos;Build with JFrog CLI&apos;) {
            steps {
                echo &quot;### START: build with jfrog cli&quot;
                jf &quot;gradle-config --repo-deploy ${ARTIFACTORY_REPO} --repo-resolve ${ARTIFACTORY_VIRTUAL_REPO}&quot;
                jf &quot;gradle assemble -x cyclonedxBom --info --build-name=${ARTIFACTORY_REPO} --build-number=${BUILD_NUMBER}&quot;
            }
        }
        stage(&apos;Generate SBOM&apos;) {
            steps {
                echo &quot;### START: generate SBOM using CycloneDX plugin&quot;
                jf &quot;gradle cyclonedxBom --info --build-name=${ARTIFACTORY_REPO} --build-number=${BUILD_NUMBER}&quot;
            }
        }
        stage(&apos;Publish SBOM to Dependency-Track&apos;) {
            steps {
                echo &quot;### START: publich SBOM to Dependency-Track&quot;
                script {
                    // 1. Get the full path of the JAR files that match a pattern.
                    def jarFilePath = sh(script: &quot;find . -path &apos;./${env.JAR_FILE_PATTERN}&apos;&quot;, returnStdout: true).trim()
                    if (jarFilePath.isEmpty()) {
                        error &quot;JAR file not found with pattern: ${env.JAR_FILE_PATTERN}&quot;
                    }
                  
                    // 2. Extract only the file name from the full path.
                    def jarFileName = sh(script: &quot;basename &apos;${jarFilePath}&apos;&quot;, returnStdout: true).trim()
                    echo &quot;Found JAR file: ${jarFileName}&quot;
                    
                    // 3. Extract project name and version using regular expressions.
                    def projectInfo = parseJarName(jarFileName)
                    if (projectInfo == null) {
                        error &quot;Could not parse project name and version from JAR file: ${jarFileName}&quot;
                    }

                    def parsedProjectName = projectInfo[0]
                    def parsedProjectVersion = projectInfo[1]
                    echo &quot;Parsed Project Name: ${parsedProjectName}&quot;
                    echo &quot;Parsed Project Version: ${parsedProjectVersion}&quot;
                  
                    withCredentials([string(credentialsId: &quot;${env.DEPENDENCY_TRACK_API_KEY_ID}&quot;, variable: &apos;API_KEY&apos;)]) {
                        dependencyTrackPublisher artifact: &quot;${env.SBOM_FILE_PATH}&quot;,
                        projectName: parsedProjectName,
                        projectVersion: parsedProjectVersion,
                        synchronous: true,
                        dependencyTrackApiKey: API_KEY
                    }
                }
            }
        }
        stage(&quot;Run Unit Tests&quot;){
            steps{
                echo &quot;### START: run unit tests&quot;
                jf &quot;gradle test -x check --info --build-name=${ARTIFACTORY_REPO} --build-number=${BUILD_NUMBER}&quot;
            }
            post {
                always {
                    junit &apos;build/test-results/test/*.xml&apos;
                    script {
                        try {
                            def totalTests = 0
                            def failedTests = 0
                            def skippedTests = 0
                            
                            def testFilesOutput = sh(script: &quot;find build/test-results/test -name &apos;*.xml&apos;&quot;, returnStdout: true).trim()
                            
                            if (testFilesOutput.isEmpty()) {
                                echo &quot;No JUnit test result files found.&quot;
                                testResultsProps = &quot;tests.status=no-results&quot;
                            } else {
                                def testFiles = testFilesOutput.split(&apos;\\n&apos;)
                                testFiles.each { filePath -&gt;
                                    if (fileExists(filePath)) {
                                        // extract all necessary attribute values from the testsuite tag using the awk command
                                        // get as a comma-separated string in the order &quot;tests,failures,errors,skipped&quot;
                                        def awkCommand = &apos;&apos;&apos;awk -F&apos;&quot;&apos; &apos;/&lt;testsuite/ {for(i=1;i&lt;=NF;i++){if($i~/tests=$/){t=$(i+1)} if($i~/failures=$/){f=$(i+1)} if($i~/errors=$/){e=$(i+1)} if($i~/skipped=$/){s=$(i+1)}} printf &quot;%d,%d,%d,%d&quot;, t, f, e, s}&apos; &apos;&apos;&apos;
                                        def countsStr = sh(script: &quot;${awkCommand} &apos;${filePath}&apos;&quot;, returnStdout: true).trim()
                                        
                                        def counts = countsStr.split(&apos;,&apos;)
                                        if (counts.size() == 4) {
                                            totalTests += counts[0].toInteger()
                                            failedTests += counts[1].toInteger() // failures
                                            failedTests += counts[2].toInteger() // errors
                                            skippedTests += counts[3].toInteger()
                                        }
                                    }
                                }
                                
                                def passedTests = totalTests - failedTests - skippedTests
                                testResultsProps = &quot;tests.total=${totalTests};tests.passed=${passedTests};tests.failed=${failedTests};tests.skipped=${skippedTests}&quot;
                                echo &quot;Generated test result properties for Artifactory: ${testResultsProps}&quot;
                            }
                        } catch (e) {
                            echo &quot;Could not parse JUnit test results. Skipping property attachment. Error: ${e.message}&quot;
                            testResultsProps = &quot;tests.status=unavailable&quot;
                        }
                    }
                }
            }
        }
        stage(&quot;Analyze test codes coverage&quot;){
            steps{
                echo &quot;### START: analyze a test code coverage&quot;
                jf &quot;gradle jacocoTestReport --info --build-name=${ARTIFACTORY_REPO} --build-number=${BUILD_NUMBER}&quot;
            }
            post {
                always {
                    recordCoverage(
                        tools: [[parser: &apos;JACOCO&apos;, pattern: &apos;build/reports/jacoco/test/jacocoTestReport.xml&apos;]],
                        id: &apos;jacoco&apos;, name: &apos;JaCoCo Coverage&apos;,
                        sourceCodeRetention: &apos;EVERY_BUILD&apos;,
                        qualityGates: [
                            [threshold: 60.0, metric: &apos;LINE&apos;, baseline: &apos;PROJECT&apos;, unstable: true],
                            [threshold: 60.0, metric: &apos;BRANCH&apos;, baseline: &apos;PROJECT&apos;, unstable: true]]
                    )
                }
            }
        }
        stage(&quot;Analyze binaries with SpotBugs&quot;){
            steps{
                echo &quot;### START: analyze binaries with spotbugs&quot;
                jf &quot;gradle spotbugsMain spotbugsTest --info --build-name=${ARTIFACTORY_REPO} --build-number=${BUILD_NUMBER}&quot;
            }
            post {
                always {
                    recordIssues tools: [
                        spotBugs(pattern: &apos;build/reports/spotbugs/*.xml&apos;)
                    ]
                }
            }
        }
        stage(&quot;Analyze codes with PMD&quot;){
            steps{
                echo &quot;### START: analyze codes with pmd&quot;
                jf &quot;gradle pmdMain pmdTest --info --build-name=${ARTIFACTORY_REPO} --build-number=${BUILD_NUMBER}&quot;
            }
            post {
                always {
                    recordIssues tools: [
                        pmdParser(pattern: &apos;build/reports/pmd/*.xml&apos;)
                    ]
                }
            }
        }
        stage(&quot;Analyze codes with Checkstyle&quot;){
            steps{
                echo &quot;### START: analyze codes with checkstyle&quot;
                jf &quot;gradle checkstyleMain checkstyleTest --info --build-name=${ARTIFACTORY_REPO} --build-number=${BUILD_NUMBER}&quot;
            }
            post {
                always {
                    recordIssues tools: [
                        checkStyle(pattern: &apos;build/reports/checkstyle/*.xml&apos;)
                    ]
                }
            }
        }
        stage(&apos;Generate a Javadoc&apos;) {
            steps {
                echo &quot;### START: generate a javadoc&quot;
                jf &quot;gradle javadoc --info --build-name=${ARTIFACTORY_REPO} --build-number=${BUILD_NUMBER}&quot;
            }
        }
        stage(&apos;Publish a Javadoc&apos;) {
            steps {
                echo &quot;### START: publish a javadoc using javadoc plugin&quot;
                javadoc javadocDir: &apos;build/docs/javadoc&apos;, keepAll: true
            }
        }
        stage(&apos;Release an artifact to Artifactory&apos;) {
            steps {
                echo &quot;### START: release an artifact to artifactory&quot;
                script {
                    def props = &quot;build.name=${ARTIFACTORY_REPO};build.number=${BUILD_NUMBER};${testResultsProps}&quot;
                    def spec = &quot;&quot;&quot;{
                        &quot;files&quot;: [
                            {
                                &quot;pattern&quot;: &quot;${JAR_FILE_PATTERN}&quot;,
                                &quot;target&quot;: &quot;${ARTIFACTORY_REPO}&quot;,
                                &quot;props&quot;: &quot;${props}&quot;
                            }
                        ]
                    }&quot;&quot;&quot;
                    writeFile file: &apos;upload.spec&apos;, text: spec
                    jf &quot;rt u --spec=upload.spec&quot;
                }
            }
        }
        stage(&apos;Publish a build info to Artifactory&apos;) {
            steps {
                echo &quot;### START: publish a build info to Artifactory&quot;
                jf &quot;rt build-publish ${ARTIFACTORY_REPO} ${BUILD_NUMBER}&quot;
            }
        }
    }
    post{
        always{
            echo &quot;========always========&quot;
        }
        success{
            echo &quot;========pipeline executed successfully ========&quot;
        }
        failure{
            echo &quot;========pipeline execution failed========&quot;
        }
    }
}</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>
